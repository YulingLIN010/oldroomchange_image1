<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>舊屋換新風格（照片上傳版）</title>
  <style>
    :root{
      --bg:#FFF8F0;
      --card:#FFFFFF;
      --text:#1F2D3D;
      --muted:#6B7280;
      --line:#F4D2D2;
      --brand:#FF7EB6;
      --brand-2:#64C2FF;
      --ok:#35B36B;
      --warn:#F6B01A;
    }
    *{box-sizing:border-box}
    body{font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans TC",Arial,sans-serif;margin:0;padding:24px;background:linear-gradient(180deg,#FFF8F0 0%, #FFEFF7 100%);color:var(--text)}
    h1{font-size:22px;margin:0 0 16px}
    h2{font-size:16px;margin:24px 0 8px}
    .card{background:var(--card);border:2px solid var(--line);border-radius:16px;padding:16px;margin-bottom:16px;box-shadow:0 6px 20px rgba(255,126,182,.15)}
    label{display:block;margin:8px 0 4px;font-size:12px;color:var(--muted)}
    input,select,button,textarea{background:#fff;color:var(--text);border:2px solid var(--line);border-radius:12px;padding:10px 12px;font-size:14px}
    input[type="color"]{padding:0;height:40px;width:60px;border-radius:10px}
    button{cursor:pointer;background:linear-gradient(90deg,var(--brand),var(--brand-2));color:#fff;border:none}
    button.ghost{background:#fff;color:var(--text);border:2px dashed var(--line)}
    .row{display:flex;gap:12px;flex-wrap:wrap}
    .col{flex:1;min-width:260px}
    .imgwall{display:grid;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));gap:10px}
    .imgwall figure{margin:0;background:#fff;border:2px solid var(--line);border-radius:12px;overflow:hidden}
    .imgwall img{display:block;width:100%;height:auto}
    .badge{display:inline-block;background:var(--brand-2);border:2px solid var(--line);border-radius:999px;padding:2px 10px;font-size:12px;margin-left:6px;color:#053B5C}
    .small{font-size:12px;color:var(--muted)}
    .tip{background:#FFF2F8;border:2px solid #FFD5E8;border-radius:12px;padding:10px;color:#7A294A}
    .ok{color:var(--ok)} .warn{color:var(--warn)}
    .toolbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .toolbar .chip{background:#FFF2F8;border:2px solid #FFD5E8;border-radius:999px;padding:4px 10px;font-size:12px;color:#7A294A}
    .kbd{display:inline-block;border:2px solid var(--line);border-bottom-width:4px;border-radius:8px;padding:0 6px;background:#fff;font-weight:700}
    canvas{max-width:100%;border:2px dashed var(--line);border-radius:12px;background:#fff}

    /* palette cards */
    .palgrid{display:grid;grid-template-columns:repeat(auto-fill,minmax(180px,1fr));gap:10px;margin:6px 0 10px}
    .palcard{border:2px solid var(--line);border-radius:12px;overflow:hidden;background:#fff;cursor:pointer;transition:.15s box-shadow,.15s transform}
    .palcard:hover{box-shadow:0 6px 16px rgba(100,194,255,.25);transform:translateY(-1px)}
    .palcard.selected{outline:3px solid var(--brand-2)}
    .palcard .name{padding:8px 10px;font-size:12px;color:var(--muted);border-top:2px solid var(--line);display:flex;justify-content:space-between;align-items:center}
    .swrow{display:flex;height:38px}
    .sw{flex:1}
    .sw label{display:block;font-size:10px;margin:0;padding:4px 6px;color:#fff;text-shadow:0 1px 2px rgba(0,0,0,.25)}
    .btnline{display:flex;gap:8px;align-items:center;margin:6px 0}

    /* segmented tabs */
    .segline{display:inline-flex;border:2px solid var(--line);border-radius:999px;overflow:hidden}
    .seg{background:#fff;color:var(--text);border:0;padding:8px 12px}
    .seg.active{background:linear-gradient(90deg,var(--brand),var(--brand-2));color:#fff}
  </style>
<script>window.API_BASE="https://oldroomchange-image3.onrender.com";</script>
</head>
<body>
  <h1>舊屋換新風格（照片上傳版）<span id="status" class="badge">待上傳</span></h1>

  <div class="card">
    <h2>1) 上傳原圖 → 自動偵測（結構＋深度）</h2>
    <div class="row">
      <div class="col">
        <label>原始室內照片</label>
        <input type="file" id="fileInput" accept="image/*"/>
<p class="small">上傳限制：原始照片 <b>2MB 以內</b>（若過大請先壓縮）</p>
        <button id="btnAnalyze">送出 /analyze</button>
        <p class="small">支援 JPG / PNG，較大圖會自動等比處理。</p>
      </div>
      <div class="col">
        <label>jobId</label><input id="jobId" placeholder="尚未產生" readonly/>
      </div>
    </div>
  </div>

  <div class="card">
    <h2>2) 遮罩人工修正（務必鎖住結構，只放開表面可改區）</h2>
    <div class="row">
      <div class="col">
        <div class="tip">
          <b>如何畫？</b><br/>
          • <span class="ok">可改</span>：牆面塗料/飾板、天花、地坪、燈具、<b>可移動家具</b>（櫃、沙發、桌椅、床、窗簾等）。<br/>
          • <span class="warn">必鎖</span>：<b>樑、柱、牆體、門窗</b>（含窗框）、固定中島、樓梯、結構開口位置與尺寸。<br/>
          • 建議：邊緣留 3–5px 緩衝避免滲色；先大筆刷勾輪廓，再小筆修邊。<br/>
          • 快捷鍵：<span class="kbd">E</span> 可改、<span class="kbd">R</span> 鎖定、<span class="kbd">Z</span> 復原、<span class="kbd">Y</span> 重做。<br/>
          • 送出前請放大檢查牆角、門框四邊、窗台、樑柱交界是否鎖好。
        </div>
        <div class="toolbar" style="margin-top:8px">
          <span class="chip">筆刷半徑：<span id="brushVal">20</span>px</span>
          <input type="range" id="brush" min="6" max="80" value="20" style="width:180px"/>
          <button class="ghost" data-tool="unlock">可改區域（E）</button>
          <button class="ghost" data-tool="lock">鎖定區域（R）</button>
          <button class="ghost" id="btnUndo">復原（Z）</button>
          <button class="ghost" id="btnRedo">重做（Y）</button>
          <button id="btnSaveMask">上傳修正遮罩 /masks/save</button>
        </div>
      </div>
      <div class="col">
        <div class="toolbar" style="margin:8px 0">
          <button class="ghost" id="btnZoomOut">縮小 -</button>
          <button class="ghost" id="btnZoomIn">放大 +</button>
          <button class="ghost" id="btnZoomReset">重置視圖</button>
          <span class="chip">遮罩顯示透明度：<span id="opVal">35</span>%</span>
          <input type="range" id="overlayOpacity" min="0" max="90" value="35" style="width:140px"/>
          <button class="ghost" id="btnToggleEdges">顯示/隱藏邊緣</button>
          <span class="chip">邊緣門檻：<span id="thrVal">60</span></span>
          <input type="range" id="edgeThr" min="20" max="140" value="60" style="width:140px"/>
          <span class="chip">保護半徑：<span id="radVal">3</span>px</span>
          <input type="range" id="edgeRad" min="1" max="6" value="3" style="width:140px"/>
          <button class="ghost" id="btnProtectEdges">一鍵保護邊緣</button>
          <button class="ghost" id="btnCleanSpecks">自動清理小雜點</button>
          <button class="ghost" id="btnSmartFix">邊緣智慧修補</button>
        </div>
        <div id="canvasWrap" style="position:relative; width:100%; max-width:100%; border-radius:12px; overflow:hidden; border:2px dashed var(--line); background:#fff">
          <canvas id="maskCanvas" width="0" height="0"></canvas>
          <canvas id="uiCanvas" width="0" height="0" style="position:absolute; left:0; top:0; pointer-events:none"></canvas>
        </div>
        <p class="small">提示：滑鼠滾輪可縮放；按住 <span class="kbd">Space</span> 拖曳可平移。綠色筆＝<b>可改</b>（擦成透明），紅色筆＝<b>鎖定</b>（補回白）。</p>
      </div>
    </div>
  </div>

  <div class="card">
    <h2>3) 選 1–3 風格（同色系）→ 批次生成（預覽含 LOGO）</h2>
    <div class="row">
      <div class="col">
        <label>可選風格（最多 3）</label>
        <select id="styleSelect" multiple size="6"></select>
      </div>
      <div class="col">
        <label>色系來源</label>
        <div class="segline" style="margin-bottom:8px">
          <button class="seg active" id="tabPreset">色卡</button>
          <button class="seg" id="tabCustom">自訂</button>
        </div>

        <div id="palettePreset">
          <div class="btnline">
            <button class="ghost" id="btnRandPal">隨機推薦一組</button>
            <span class="small">點一下色卡即可套用；如果要手動微調，請切換到「自訂」。</span>
          </div>
          <div id="paletteGrid" class="palgrid"></div>
        </div>

        <div id="paletteCustom" style="display:none">
          <div class="row">
            <div><span class="small">主色</span><br/><input type="color" id="cMain" value="#1E3A8A"/></div>
            <div><span class="small">配1</span><br/><input type="color" id="c1" value="#D4AF37"/></div>
            <div><span class="small">配2</span><br/><input type="color" id="c2" value="#ECECEC"/></div>
            <div><span class="small">配3</span><br/><input type="color" id="c3" value="#7C8798"/></div>
          </div>
        </div>

        <div class="row" style="margin-top:8px">
          <div class="col"><label>LOGO 位置</label>
            <select id="logoPos"><option>bottom-right</option><option>bottom-left</option><option>top-right</option><option>top-left</option><option>center</option></select>
          </div>
          <div class="col"><label>比例</label><input id="logoScale" type="number" step="0.01" value="0.18"/></div>
          <div class="col"><label>不透明度</label><input id="logoOpacity" type="number" step="0.05" value="0.9"/></div>
        </div>
        <button style="margin-top:8px" id="btnBatch">產生 /render/batch</button>
        <p class="small">LOGO 檔案固定讀取 <code>static/logo/LOGO.png</code>（後端設定）。</p>
      </div>
    </div>
  </div>

  <div class="card">
    <h2>4) 多風格對比牆</h2>
    <div id="wall" class="imgwall"></div>
  </div>

  <div class="card">
    <h2>5) 家具編修（替換／改色 → 最終圖）</h2>
    <div class="row">
      <div class="col">
        <label>基底圖（輸入 style 名稱，對應 previews_clean/<style>.png）</label>
        <input id="baseStyle" placeholder="例如：現代風"/>
        <label>操作類型</label>
        <select id="opType"><option value="replace">replace</option><option value="recolor">recolor</option></select>
        <label>局部遮罩（黑=可改 / 白=鎖）</label><input type="file" id="editMask" accept="image/png"/>
        <label>replace 描述 / recolor 色彩</label>
        <input id="editSpec" placeholder="現代風L型布沙發，金屬腳"/>
        <input id="editColor" type="color" value="#1E3A8A"/>
        <button id="btnEdit">送出 /render/furniture-edit</button>
      </div>
      <div class="col">
        <h3>最終輸出</h3><img id="finalImg"/>
      </div>
    </div>
  </div>

<script>
const $ = (s)=>document.querySelector(s);
const api = (p)=>p;
let g = {jobId:null, imgs:[]};

// ===== 色卡資料 =====
const PALETTES = [
  {id:'scandi_soft', name:'北歐柔霧', c:['#E6E8EA','#6BA5A1','#F4D6CC','#6C7278']},
  {id:'wabi_wood', name:'侘寂自然', c:['#D8CFC4','#8A7F74','#E9E4DA','#6F8A73']},
  {id:'modern_gold_black', name:'現代金黑', c:['#111827','#D4AF37','#ECECEC','#7C8798']},
  {id:'industrial_cool', name:'工業冷灰', c:['#2B2F33','#6B7280','#C7CBD1','#8892A0']},
  {id:'milk_tea', name:'奶茶莫蘭迪', c:['#D7C2AE','#A48C7A','#EFE7DE','#8E9AA6']},
  {id:'coastal', name:'海岸藍白', c:['#F3F7FB','#2E6F95','#E8F1F8','#9CBBD3']},
  {id:'forest_sage', name:'森林鼠尾草', c:['#EDEAE3','#6C8B74','#DAC9B4','#7A8D8C']},
  {id:'pastel_green_pink', name:'莫蘭迪粉綠', c:['#EDE8E4','#9AB5A7','#F2D5D5','#9CA3AF']},
  {id:'classic_bw_gold', name:'經典黑白金', c:['#0F172A','#FFFFFF','#D4AF37','#9CA3AF']},
];
function makePalCard(p){
  const div = document.createElement('div');
  div.className='palcard'; div.dataset.id=p.id;
  div.innerHTML = `
    <div class="swrow">
      <div class="sw" style="background:${p.c[0]}"><label>主</label></div>
      <div class="sw" style="background:${p.c[1]}"><label>配1</label></div>
      <div class="sw" style="background:${p.c[2]}"><label>配2</label></div>
      <div class="sw" style="background:${p.c[3]}"><label>配3</label></div>
    </div>
    <div class="name"><span>${p.name}</span><span class="small">${p.c.join(' ')}</span></div>`;
  div.onclick = ()=>applyPalette(p.c, div);
  return div;
}
function applyPalette(c, cardEl){
  // 仍然同步到隱藏的 inputs（/render/batch 直接讀 inputs，避免邏輯分歧）
  $('#cMain').value = c[0]; $('#c1').value = c[1]; $('#c2').value = c[2]; $('#c3').value = c[3];
  document.querySelectorAll('.palcard').forEach(x=>x.classList.remove('selected'));
  if(cardEl) cardEl.classList.add('selected');
}
function buildPaletteGrid(){
  const grid = $('#paletteGrid'); grid.innerHTML='';
  PALETTES.forEach(p=> grid.appendChild(makePalCard(p)) );
}
function randPalette(){
  const p = PALETTES[Math.floor(Math.random()*PALETTES.length)];
  const card = document.querySelector(\`.palcard[data-id="\${p.id}"]\`);
  applyPalette(p.c, card);
}

// ===== 風格清單 =====
fetch(api('/styles')).then(r=>r.json()).then(list=>{
  const sel=$('#styleSelect');
  list.forEach(it=>{ const o=document.createElement('option'); o.value=it.name||it; o.textContent=(it.name||it); sel.appendChild(o); });
});

// ===== analyze =====
const MAX_BYTES = 2 * 1024 * 1024; // 2MB
$('#btnAnalyze').onclick = async ()=>{
  const f=$('#fileInput').files[0]; if(!f){alert('請選圖片');return;}
  if(f.size>MAX_BYTES){ alert('原始照片超過 2MB，請先壓縮後再上傳。'); return; }
  const fd=new FormData(); fd.append('image',f);
  const res=await fetch(api('/analyze'),{method:'POST',body:fd}); const j=await res.json(); if(!res.ok){alert(JSON.stringify(j));return;}
  g.jobId=j.jobId; $('#jobId').value=g.jobId; $('#status').textContent='job: '+g.jobId;
  const baseUrl = api(`/jobs/${g.jobId}/original.jpg`);
  const murl=(j.masks||{}).editable_surface||'';
  await initCanvas(baseUrl, murl);
};

// ===== tabs: 色卡 / 自訂 =====
function setTab(which){
  const a=$('#tabPreset'), b=$('#tabCustom');
  const p=$('#palettePreset'), c=$('#paletteCustom');
  if(which==='preset'){ a.classList.add('active'); b.classList.remove('active'); p.style.display='block'; c.style.display='none'; }
  else { b.classList.add('active'); a.classList.remove('active'); c.style.display='block'; p.style.display='none'; }
}
$('#tabPreset').onclick=()=>setTab('preset');
$('#tabCustom').onclick=()=>setTab('custom');

// ===== save mask =====
$('#btnSaveMask').onclick = async ()=>{
  if(!g.jobId){alert('先 /analyze');return;}
  const can=$('#maskCanvas'); const blob=await new Promise(r=>can.toBlob(r,'image/png'));
  const fd=new FormData(); fd.append('jobId',g.jobId); fd.append('mask',blob,'mask.png');
  const res=await fetch(api('/masks/save'),{method:'POST',body:fd}); const j=await res.json();
  if(!res.ok){alert(JSON.stringify(j));return;} alert('已儲存最終遮罩 ✅');
};

// ===== batch render =====
$('#btnBatch').onclick = async ()=>{
  if(!g.jobId){alert('先 /analyze');return;}
  const styles=Array.from($('#styleSelect').selectedOptions).slice(0,3).map(o=>o.value); if(styles.length<1){alert('至少選一種風格');return;}
  const payload={ jobId:g.jobId, styles, palette:{main:$('#cMain').value, acc1:$('#c1').value, acc2:$('#c2').value, acc3:$('#c3').value},
    logo:{ pos:$('#logoPos').value, scale:parseFloat($('#logoScale').value||'0.18'), opacity:parseFloat($('#logoOpacity').value||'0.9') } };
  const res=await fetch(api('/render/batch'),{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)});
  const j=await res.json(); if(!res.ok){alert(JSON.stringify(j));return;}
  const wall=$('#wall'); wall.innerHTML=''; g.imgs=j.images||[];
  g.imgs.forEach(it=>{ const fig=document.createElement('figure'); const img=document.createElement('img'); img.src=api(it.url); const cap=document.createElement('figcaption'); cap.className='small'; cap.textContent=`${it.style}｜keypoint_error=${(j.qc?.[it.style]?.keypoint_error??'')}`; fig.appendChild(img); fig.appendChild(cap); wall.appendChild(fig); });
};

// ===== furniture edit =====
$('#btnEdit').onclick = async ()=>{
  if(!g.jobId){alert('先 /analyze');return;}
  const maskFile=$('#editMask').files[0]; if(!maskFile){alert('請選局部遮罩');return;}
  const fd=new FormData(); fd.append('jobId',g.jobId); fd.append('mask',maskFile,'user_edit.png');
  const up=await fetch(api('/upload/mask'),{method:'POST',body:fd}); const uj=await up.json(); if(!up.ok){alert(JSON.stringify(uj));return;}
  const baseStyle=$('#baseStyle').value.trim(); const type=$('#opType').value;
  const ops=[ type==='replace'? {type:'replace', target:'object', mask:uj.maskUrl, spec:$('#editSpec').value} : {type:'recolor', target:'object', mask:uj.maskUrl, color:$('#editColor').value} ];
  const res=await fetch(api('/render/furniture-edit'),{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({jobId:g.jobId, baseImageId:baseStyle, operations:ops})});
  const j=await res.json(); if(!res.ok){alert(JSON.stringify(j));return;}
  $('#finalImg').src=api(j.imageUrl);
};

// ===== 初始：建立色卡 =====
buildPaletteGrid(); randPalette(); setTab('preset');

// ===== Painter v2: zoom/pan + edge assist + colored cursor =====
let painter = null;
async function initCanvas(baseUrl, maskUrl){
  const baseImg = new Image(); baseImg.crossOrigin="anonymous"; baseImg.src=baseUrl;
  const initMask = new Image(); initMask.crossOrigin="anonymous"; initMask.src=api(maskUrl);
  await new Promise(r=>baseImg.onload=r); await new Promise(r=>initMask.onload=r);

  const can = $('#maskCanvas'), ui = $('#uiCanvas');
  const ctx = can.getContext('2d'); const uictx = ui.getContext('2d');
  can.width = ui.width = baseImg.width; can.height = ui.height = baseImg.height;

  // Offscreen mask buffer: 白=鎖(不透明)；透明=可改
  const maskBuf = document.createElement('canvas'); maskBuf.width=baseImg.width; maskBuf.height=baseImg.height;
  const mctx = maskBuf.getContext('2d'); mctx.clearRect(0,0,maskBuf.width,maskBuf.height);
  mctx.drawImage(initMask,0,0,maskBuf.width,maskBuf.height);

  // Edge buffer
  const edgeBuf = document.createElement('canvas'); edgeBuf.width=baseImg.width; edgeBuf.height=baseImg.height;
  const ectx = edgeBuf.getContext('2d'); ectx.drawImage(baseImg,0,0);
  const eImg = ectx.getImageData(0,0,edgeBuf.width,edgeBuf.height);
  // Sobel edge
  const w=edgeBuf.width,h=edgeBuf.height; const gray=new Uint8ClampedArray(w*h);
  for(let i=0, p=0;i<eImg.data.length;i+=4, p++){ gray[p]=(eImg.data[i]*0.299 + eImg.data[i+1]*0.587 + eImg.data[i+2]*0.114)|0; }
  const Gx=[-1,0,1,-2,0,2,-1,0,1], Gy=[-1,-2,-1,0,0,0,1,2,1];
  const edge=new Uint8ClampedArray(w*h);
  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      let sx=0, sy=0, k=0;
      for(let j=-1;j<=1;j++) for(let i=-1;i<=1;i++,k++){
        const v = gray[(y+j)*w+(x+i)];
        sx += v*Gx[k]; sy += v*Gy[k];
      }
      const mag = Math.min(255, Math.hypot(sx,sy)|0);
      edge[y*w+x] = mag;
    }
  }
  const edgeImg = ectx.createImageData(w,h);
  let edgeThr = 60; // threshold
  function updateEdgeOverlay(){
    for(let p=0, i=0;p<w*h;p++, i+=4){
      const v=edge[p]; edgeImg.data[i]=64; edgeImg.data[i+1]=200; edgeImg.data[i+2]=255; edgeImg.data[i+3]=(v>=edgeThr? 180: 0);
    }
    ectx.putImageData(edgeImg,0,0);
  }
  updateEdgeOverlay();
  let showEdges=false;

  // View transform
  let scale=1, ox=0, oy=0; const MIN_S=0.2, MAX_S=6;
  let isPanning=false, spaceDown=false, lastX=0, lastY=0;
  const overlayOpacity = $('#overlayOpacity'); const opVal=$('#opVal');
  function render(){
    ctx.setTransform(scale,0,0,scale,ox,oy);
    ctx.clearRect(-ox/scale,-oy/scale, can.width/scale, can.height/scale);
    ctx.drawImage(baseImg,0,0);
    // draw mask with adjustable opacity
    const alpha = Math.max(0, Math.min(1, (parseInt(overlayOpacity.value,10)||35)/100));
    ctx.globalAlpha = alpha; ctx.drawImage(maskBuf,0,0); ctx.globalAlpha = 1;
    if(showEdges){ ctx.drawImage(edgeBuf,0,0); }
    // draw cursor
    uictx.setTransform(scale,0,0,scale,ox,oy);
    uictx.clearRect(-ox/scale,-oy/scale, ui.width/scale, ui.height/scale);
    if(cursor.visible){
      uictx.beginPath(); uictx.arc(cursor.x, cursor.y, cursor.r, 0, Math.PI*2);
      uictx.lineWidth = 2/scale; uictx.strokeStyle = (cursor.tool==='unlock')?'#22c55e':'#ef4444';
      uictx.stroke();
    }
    opVal.textContent = Math.round(alpha*100);
  }
  function screenToImage(sx, sy){ return {x:(sx-ox)/scale, y:(sy-oy)/scale}; }

  // Painting state
  const brush = $('#brush'); const brushVal=$('#brushVal');
  const undoStack=[], redoStack=[]; const MAX_STACK=20;
  let tool='unlock', drawing=false;
  const cursor = {x:0,y:0,r:parseInt(brush.value,10)||20, tool:'unlock', visible:false};

  function snapshot(){
    const m = mctx.getImageData(0,0,maskBuf.width,maskBuf.height);
    undoStack.push(m); if(undoStack.length>MAX_STACK) undoStack.shift(); redoStack.length=0;
  }
  function restoreFrom(stackFrom, stackTo){
    if(stackFrom.length===0) return;
    const cur = mctx.getImageData(0,0,maskBuf.width,maskBuf.height);
    stackTo.push(cur);
    const imgData = stackFrom.pop();
    mctx.putImageData(imgData,0,0);
    render();
  }
  function paintAt(ix,iy){
    const r = cursor.r;
    mctx.save();
    if(tool==='unlock'){ // erase to transparent
      mctx.globalCompositeOperation='destination-out';
      mctx.beginPath(); mctx.arc(ix,iy,r,0,Math.PI*2); mctx.fillStyle='rgba(0,0,0,1)'; mctx.fill();
    }else{ // lock: paint white
      mctx.globalCompositeOperation='source-over';
      mctx.beginPath(); mctx.arc(ix,iy,r,0,Math.PI*2); mctx.fillStyle='rgba(255,255,255,1)'; mctx.fill();
    }
    mctx.restore();
  }

  // Events
  document.querySelectorAll('[data-tool]').forEach(b=>{ b.onclick=()=>{ tool=b.getAttribute('data-tool'); cursor.tool=tool; render(); }; });
  document.getElementById('btnUndo').onclick=()=>restoreFrom(undoStack, redoStack);
  document.getElementById('btnRedo').onclick=()=>restoreFrom(redoStack, undoStack);
  brush.oninput=()=>{ cursor.r=parseInt(brush.value,10)||20; brushVal.textContent=brush.value; render(); };

  can.addEventListener('wheel', (e)=>{
    e.preventDefault();
    const rect=can.getBoundingClientRect();
    const mx=e.clientX-rect.left, my=e.clientY-rect.top;
    const before=screenToImage(mx,my);
    const s = Math.exp(-e.deltaY*0.001);
    const ns = Math.max(MIN_S, Math.min(MAX_S, scale*s));
    scale = ns;
    const after=screenToImage(mx,my);
    ox += (mx - (after.x*scale)) - (mx - (before.x*scale));
    oy += (my - (after.y*scale)) - (my - (before.y*scale));
    render();
  }, {passive:false});
  can.addEventListener('mousedown',(e)=>{
    const rect=can.getBoundingClientRect();
    lastX=e.clientX-rect.left; lastY=e.clientY-rect.top;
    if(spaceDown){ isPanning=true; return; }
    drawing=true; snapshot();
    const {x,y}=screenToImage(lastX,lastY); paintAt(x,y); render();
  });
  window.addEventListener('mousemove',(e)=>{
    const rect=can.getBoundingClientRect();
    const sx=e.clientX-rect.left, sy=e.clientY-rect.top;
    cursor.visible = (sx>=0 && sy>=0 && sx<=rect.width && sy<=rect.height);
    const pt=screenToImage(sx,sy); cursor.x=pt.x; cursor.y=pt.y;
    if(isPanning){
      ox += (sx-lastX); oy += (sy-lastY);
      lastX=sx; lastY=sy; render(); return;
    }
    if(drawing){ const {x,y}=pt; paintAt(x,y); render(); }
    else { render(); }
  });
  window.addEventListener('mouseup',()=>{ drawing=false; isPanning=false; });
  document.addEventListener('keydown',(e)=>{
    if(e.target.tagName==='INPUT' || e.target.tagName==='TEXTAREA') return;
    if(e.code==='Space') spaceDown=true;
    if(e.key==='e' || e.key==='E'){ tool='unlock'; cursor.tool=tool; render(); }
    if(e.key==='r' || e.key==='R'){ tool='lock'; cursor.tool=tool; render(); }
    if(e.key==='z' || e.key==='Z'){ e.preventDefault(); document.getElementById('btnUndo').click(); }
    if(e.key==='y' || e.key==='Y'){ e.preventDefault(); document.getElementById('btnRedo').click(); }
  });
  document.addEventListener('keyup',(e)=>{ if(e.code==='Space') spaceDown=false; });

  // Controls
  $('#btnZoomIn').onclick=()=>{ scale=Math.min(MAX_S, scale*1.2); render(); };
  $('#btnZoomOut').onclick=()=>{ scale=Math.max(MIN_S, scale/1.2); render(); };
  $('#btnZoomReset').onclick=()=>{ scale=1; ox=0; oy=0; render(); };
  $('#overlayOpacity').oninput=()=>render();
  $('#btnToggleEdges').onclick=()=>{ showEdges=!showEdges; render(); };
  $('#edgeThr').oninput=()=>{ edgeThr=parseInt($('#edgeThr').value||'60',10); $('#thrVal').textContent=edgeThr; updateEdgeOverlay(); render(); };
  $('#edgeRad').oninput=()=>{ $('#radVal').textContent=parseInt($('#edgeRad').value||'3',10); };

  function protectEdges(){
    const rad = parseInt($('#edgeRad').value||'3',10);
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        if(edge[y*w+x] >= edgeThr){
          mctx.save();
          mctx.globalCompositeOperation='source-over';
          mctx.beginPath(); mctx.arc(x,y,rad,0,Math.PI*2); mctx.fillStyle='rgba(255,255,255,1)'; mctx.fill();
          mctx.restore();
        }
      }
    }
  }
  function cleanSpecks(){
    const m = mctx.getImageData(0,0,w,h);
    const d = m.data;
    // simple 3x3 box blur on alpha, then threshold
    const alpha = new Uint8ClampedArray(w*h);
    for(let p=0, i=3;p<w*h;p++, i+=4) alpha[p]=d[i];
    const out = new Uint8ClampedArray(w*h);
    for(let y=1;y<h-1;y++){
      for(let x=1;x<w-1;x++){
        let s=0;
        for(let j=-1;j<=1;j++) for(let i=-1;i<=1;i++) s+= alpha[(y+j)*w+(x+i)];
        const avg = s/9;
        out[y*w+x] = (avg>180)? 255 : 0; // keep large areas
      }
    }
    // write back: 255 -> opaque white, 0 -> transparent
    for(let p=0, i=0;p<w*h;p++, i+=4){
      d[i]=255; d[i+1]=255; d[i+2]=255; d[i+3]=out[p];
    }
    mctx.putImageData(m,0,0);
  }
  $('#btnProtectEdges').onclick=()=>{ protectEdges(); render(); };
  $('#btnCleanSpecks').onclick=()=>{ cleanSpecks(); render(); };
  $('#btnSmartFix').onclick=()=>{ protectEdges(); cleanSpecks(); render(); };

  painter = { render, maskBuf, baseImg };
  render();
}

// ===== 色卡初始化 =====
function buildPaletteGrid(){ const grid = $('#paletteGrid'); grid.innerHTML=''; PALETTES.forEach(p=> grid.appendChild(makePalCard(p)) ); }
function makePalCard(p){ const div = document.createElement('div'); div.className='palcard'; div.dataset.id=p.id; div.innerHTML = `<div class="swrow"><div class="sw" style="background:${p.c[0]}"><label>主</label></div><div class="sw" style="background:${p.c[1]}"><label>配1</label></div><div class="sw" style="background:${p.c[2]}"><label>配2</label></div><div class="sw" style="background:${p.c[3]}"><label>配3</label></div></div><div class="name"><span>${p.name}</span><span class="small">${p.c.join(' ')}</span></div>`; div.onclick = ()=>applyPalette(p.c, div); return div; }
function applyPalette(c, cardEl){ $('#cMain').value = c[0]; $('#c1').value = c[1]; $('#c2').value = c[2]; $('#c3').value = c[3]; document.querySelectorAll('.palcard').forEach(x=>x.classList.remove('selected')); if(cardEl) cardEl.classList.add('selected'); }
function randPalette(){ const p = PALETTES[Math.floor(Math.random()*PALETTES.length)]; const card = document.querySelector(`.palcard[data-id="${p.id}"]`); applyPalette(p.c, card); }
buildPaletteGrid(); randPalette();
</script>
<!-- 修補補丁：上傳即時預覽 + 分析事件重綁 -->
<script>
// ===== 修補：上傳立即預覽 + 重綁分析按鈕（覆蓋舊 handler） =====
(function(){
  const MAX_MB = 2; // strict upload limit for Strikingly

  const $ = (sel)=>document.querySelector(sel);
  const api = (p)=> (p.startsWith('http') ? p : p);

  function loadImage(src) {
    return new Promise((resolve, reject)=>{
      const im = new Image();
      im.crossOrigin = "anonymous";
      im.onload = ()=>resolve(im);
      im.onerror = ()=>reject(new Error("圖片載入失敗："+src));
      im.src = src;
    });
  }

  async function initCanvas(baseUrl, maskUrl/*可省*/){
    const baseImg = await loadImage(baseUrl);
    const maskCan = $("#maskCanvas");
    const uiCan   = $("#uiCanvas");
    if(!maskCan || !uiCan){ return; }
    const w = baseImg.naturalWidth || baseImg.width;
    const h = baseImg.naturalHeight || baseImg.height;
    [maskCan, uiCan].forEach(c=>{ c.width=w; c.height=h; });

    const uictx = uiCan.getContext("2d");
    const mctx  = maskCan.getContext("2d");
    uictx.clearRect(0,0,w,h);
    uictx.drawImage(baseImg, 0,0,w,h);
    mctx.clearRect(0,0,w,h);

    if(maskUrl){
      try{
        const maskImg = await loadImage(api(maskUrl));
        mctx.drawImage(maskImg,0,0,w,h);
        uictx.drawImage(maskCan,0,0);
      }catch(e){ console.warn("初始遮罩載入失敗", e); }
    }

    if(!maskCan._patchBound){
      let drawing=false, size=40;
      const getXY=(evt)=>{
        const r=maskCan.getBoundingClientRect();
        const cx=evt.touches?evt.touches[0].clientX:evt.clientX;
        const cy=evt.touches?evt.touches[0].clientY:evt.clientY;
        return {
          x: (cx-r.left)/r.width * maskCan.width,
          y: (cy-r.top)/r.height* maskCan.height
        };
      };
      const draw=(x,y)=>{
        mctx.globalCompositeOperation='source-over';
        mctx.fillStyle='#ffffff'; // 白=鎖
        mctx.beginPath(); mctx.arc(x,y,size/2,0,Math.PI*2); mctx.fill();
        uictx.globalCompositeOperation='source-over';
        uictx.drawImage(maskCan,0,0);
      };
      const down=(e)=>{ drawing=true; const {x,y}=getXY(e); draw(x,y); };
      const move=(e)=>{ if(!drawing) return; const {x,y}=getXY(e); draw(x,y); };
      const up=()=>{ drawing=false; };

      maskCan.addEventListener('mousedown',down);
      maskCan.addEventListener('mousemove',move);
      window.addEventListener('mouseup',up);
      maskCan.addEventListener('touchstart',down,{passive:true});
      maskCan.addEventListener('touchmove',move,{passive:true});
      window.addEventListener('touchend',up,{passive:true});
      maskCan._patchBound=true;
    }
  }

  // 上傳即時預覽（不等 /analyze）
  const fileEl = $("#fileInput");
  if(fileEl && !fileEl._patchBound){
    fileEl.addEventListener('change', async (e)=>{
      const f = e.target.files && e.target.files[0];
      if(!f) return;
      if (f.size > MAX_MB * 1024 * 1024) {
        alert(`檔案過大，上限 ${MAX_MB} MB。請壓縮後再上傳。`);
        e.target.value = "";
        if(statusEl) statusEl.textContent = `已清除：超過 ${MAX_MB}MB 限制`;
        return;
      }
      const url = URL.createObjectURL(f);
      try{
        await drawImageToCanvas(url);
        if(statusEl) statusEl.textContent = `已載入本機預覽（尚未分析，限制 ${MAX_MB}MB）`;
      }catch(err){
        alert(err.message||'預覽失敗');
        if(statusEl) statusEl.textContent = '預覽失敗';
      }
    });
    fileEl._patchBound=true;
  }

  // 重綁「分析」按鈕
  const btn = $("#btnAnalyze");
  if(btn){
    btn.onclick = async ()=>{
      const f = fileEl && fileEl.files && fileEl.files[0];
      if(!f){ alert("請先選擇一張室內照片"); return; }
      const fd = new FormData(); fd.append("image", f); fd.append("mask","smart");
      const statusEl = $("#status"); if(statusEl) statusEl.textContent = "分析中…";
      try{
        const res = await fetch(api("/analyze"), {method:"POST", body:fd});
        const j = await res.json();
        if(!res.ok){ throw new Error((j && j.error) || "分析失敗"); }
        if($("#jobId")) $("#jobId").value = j.jobId || "";
        await initCanvas(api(j.original_url), j.masks && j.masks.editable_surface ? j.masks.editable_surface : null);
        if(statusEl) statusEl.textContent = "分析完成，可修遮罩";
      }catch(err){
        console.error(err);
        alert(err.message || "分析失敗");
        if(statusEl) statusEl.textContent = "分析失敗";
      }
    };
  }
})();
</script>

<!-- HOTFIX v2025-08-12: preview + API base + analyze binding -->
<script>
(function(){
  const MAX_MB = 2; // strict upload limit for Strikingly

  // 1) Backend Base URL (edit window.API_BASE to your server if not localhost)
  const API_BASE = window.API_BASE ? String(window.API_BASE).replace(/\/$/,'')
    : ((location.hostname==='localhost'||location.hostname==='127.0.0.1')
      ? 'http://localhost:5005'
      : 'https://your-backend.example.com'); // TODO: set to your real backend

  // Always use this api() (overrides any earlier version)
  window.api = (p)=> {
    if(!p) return API_BASE;
    if(/^https?:\/\//i.test(p)) return p;
    return API_BASE + (p.startsWith('/')? p : '/' + p);
  };

  // 2) Safe styles fetch (won't crash if backend unavailable)
  try {
    fetch(api('/styles'))
      .then(r=>r.ok?r.json():Promise.reject())
      .then(list=>{
        const sel=document.querySelector('#styleSelect');
        if(!sel||!Array.isArray(list)) return;
        if(sel.options.length===0){
          list.forEach(it=>{
            const o=document.createElement('option');
            o.value=it.name||it; o.textContent=(it.name||it);
            sel.appendChild(o);
          });
        }
      }).catch(()=>{});
  }catch(_){}

  // 3) Robust local preview (draw on the base canvas directly)
  const fileEl = document.querySelector('#fileInput');
  const maskCan = document.querySelector('#maskCanvas');
  const uiCan = document.querySelector('#uiCanvas');
  const statusEl = document.querySelector('#status');

  function drawImageToCanvas(url){
    return new Promise((resolve,reject)=>{
      const im = new Image();
      im.onload = ()=>{
        const w = im.naturalWidth||im.width, h = im.naturalHeight||im.height;
        [maskCan, uiCan].forEach(c=>{ c.width=w; c.height=h; });
        const mctx = maskCan.getContext('2d');
        const uictx = uiCan.getContext('2d');
        mctx.clearRect(0,0,w,h);
        uictx.clearRect(0,0,w,h);
        // 直接畫在底層，保證一定能看見預覽
        mctx.drawImage(im, 0,0,w,h);
        resolve();
      };
      im.onerror = ()=>reject(new Error('預覽失敗，無法讀取圖片'));
      im.src = url;
    });
  }

  if(fileEl){
    fileEl.addEventListener('change', async (e)=>{
      const f = e.target.files && e.target.files[0];
      if(!f) return;
      if (f.size > MAX_MB * 1024 * 1024) {
        alert(`檔案過大，上限 ${MAX_MB} MB。請壓縮後再上傳。`);
        e.target.value = "";
        if(statusEl) statusEl.textContent = `已清除：超過 ${MAX_MB}MB 限制`;
        return;
      }
      const url = URL.createObjectURL(f);
      try{
        await drawImageToCanvas(url);
        if(statusEl) statusEl.textContent = `已載入本機預覽（尚未分析，限制 ${MAX_MB}MB）`;
      }catch(err){
        alert(err.message||'預覽失敗');
        if(statusEl) statusEl.textContent = '預覽失敗';
      }
    });
  }

  // 4) Rebind Analyze button (always alerts on failure instead of silent)
  const btnAnalyze = document.querySelector('#btnAnalyze');
  if(btnAnalyze){
    btnAnalyze.onclick = async ()=>{
      const f = fileEl && fileEl.files && fileEl.files[0];
      if(!f){ alert('請先選擇一張室內照片'); return; }
      if (f.size > MAX_MB * 1024 * 1024) {
        alert(`檔案過大，上限 ${MAX_MB} MB。請壓縮後再上傳。`);
        return;
      }
      const fd = new FormData();
      fd.append('image', f);
      fd.append('mask','smart');

      if(statusEl) statusEl.textContent = '分析中…';
      try{
        const res = await fetch(api('/analyze'), { method:'POST', body: fd });
        const j = await res.json();
        if(!res.ok){ throw new Error((j && (j.error||j.message)) || '分析失敗'); }
        window.g = window.g || {};
        window.g.jobId = j.jobId;
        const jobId = j.jobId;
        const jobIdInput = document.querySelector('#jobId');
        if(jobIdInput) jobIdInput.value = jobId || '';
        const baseUrl = j.original || api(`/jobs/${jobId}/original.jpg`);
        await drawImageToCanvas(baseUrl);
        if(j.masks && j.masks.editable_surface){
          const mImg = new Image();
          mImg.crossOrigin = 'anonymous';
          mImg.onload = ()=>{
            const ctx = maskCan.getContext('2d');
            ctx.drawImage(mImg, 0,0, maskCan.width, maskCan.height);
          };
          mImg.src = j.masks.editable_surface;
        }
        if(statusEl) statusEl.textContent = '分析完成，可修遮罩';
      }catch(err){
        console.error(err);
        alert(err.message || '分析失敗');
        if(statusEl) statusEl.textContent = '分析失敗';
      }
    };
        window.g.jobId = j.jobId;
        const jobId = j.jobId;
        const jobIdInput = document.querySelector('#jobId');
        if(jobIdInput) jobIdInput.value = jobId || '';
        // 顯示後端保存的原圖（穩定路徑）
        const baseUrl = api(`/jobs/${jobId}/original.jpg`);
        await drawImageToCanvas(baseUrl);
        // 如果有建議遮罩就套上去（畫在上層）
        if(j.masks && j.masks.editable_surface){
          const mImg = new Image();
          mImg.crossOrigin = 'anonymous';
          mImg.onload = ()=>{
            const ctx = maskCan.getContext('2d');
            ctx.drawImage(mImg, 0,0, maskCan.width, maskCan.height);
          };
          mImg.src = api(j.masks.editable_surface);
        }
        if(statusEl) statusEl.textContent = '分析完成，可修遮罩';
      }catch(err){
        console.error(err);
        alert(err.message || '分析失敗');
        if(statusEl) statusEl.textContent = '分析失敗';
      }
    };
  }
})();
</script>

</body>
</html>
