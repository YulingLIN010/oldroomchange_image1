<script>
window.API_BASE = "https://oldroomchange-image3.onrender.com";

const $ = (s)=>document.querySelector(s);
const api = (p)=> (window.api ? window.api(p) : p);
let g = {jobId:null, imgs:[]};

// ===== 色卡資料 =====
const PALETTES = [
  {id:'scandi_soft', name:'北歐柔霧', c:['#E6E8EA','#6BA5A1','#F4D6CC','#6C7278']},
  {id:'wabi_wood', name:'侘寂自然', c:['#D8CFC4','#8A7F74','#E9E4DA','#6F8A73']},
  {id:'modern_gold_black', name:'現代金黑', c:['#111827','#D4AF37','#ECECEC','#7C8798']},
  {id:'industrial_cool', name:'工業冷灰', c:['#2B2F33','#6B7280','#C7CBD1','#8892A0']},
  {id:'milk_tea', name:'奶茶莫蘭迪', c:['#D7C2AE','#A48C7A','#EFE7DE','#8E9AA6']},
  {id:'coastal', name:'海岸藍白', c:['#F3F7FB','#2E6F95','#E8F1F8','#9CBBD3']},
  {id:'forest_sage', name:'森林鼠尾草', c:['#EDEAE3','#6C8B74','#DAC9B4','#7A8D8C']},
  {id:'pastel_green_pink', name:'莫蘭迪粉綠', c:['#EDE8E4','#9AB5A7','#F2D5D5','#9CA3AF']},
  {id:'classic_bw_gold', name:'經典黑白金', c:['#0F172A','#FFFFFF','#D4AF37','#9CA3AF']},
];
function makePalCard(p){
  const div = document.createElement('div');
  div.className='palcard'; div.dataset.id=p.id;
  div.innerHTML = `
    <div class="swrow">
      <div class="sw" style="background:${p.c[0]}"><label>主</label></div>
      <div class="sw" style="background:${p.c[1]}"><label>配1</label></div>
      <div class="sw" style="background:${p.c[2]}"><label>配2</label></div>
      <div class="sw" style="background:${p.c[3]}"><label>配3</label></div>
    </div>
    <div class="name"><span>${p.name}</span><span class="small">${p.c.join(' ')}</span></div>`;
  div.onclick = ()=>applyPalette(p.c, div);
  return div;
}
function applyPalette(c, cardEl){
  // 仍然同步到隱藏的 inputs（/render/batch 直接讀 inputs，避免邏輯分歧）
  $('#cMain').value = c[0]; $('#c1').value = c[1]; $('#c2').value = c[2]; $('#c3').value = c[3];
  document.querySelectorAll('.palcard').forEach(x=>x.classList.remove('selected'));
  if(cardEl) cardEl.classList.add('selected');
}
function buildPaletteGrid(){
  const grid = $('#paletteGrid'); grid.innerHTML='';
  PALETTES.forEach(p=> grid.appendChild(makePalCard(p)) );
}
function randPalette(){
  const p = PALETTES[Math.floor(Math.random()*PALETTES.length)];
  const card = document.querySelector(\`.palcard[data-id="\${p.id}"]\`);
  applyPalette(p.c, card);
}

// ===== 風格清單 =====
fetch(api('/styles')).then(r=>r.json()).then(list=>{
  const sel=$('#styleSelect');
  list.forEach(it=>{ const o=document.createElement('option'); o.value=it.name||it; o.textContent=(it.name||it); sel.appendChild(o); });
});

// ===== analyze =====
const MAX_BYTES = 2 * 1024 * 1024; // 2MB
$('#btnAnalyze').onclick = async ()=>{
  const f=$('#fileInput').files[0]; if(!f){alert('請選圖片');return;}
  if(f.size>MAX_BYTES){ alert('原始照片超過 2MB，請先壓縮後再上傳。'); return; }
  const fd=new FormData(); fd.append('image',f);
  const res=await fetch(api('/analyze'),{method:'POST',body:fd}); const j=await res.json(); if(!res.ok){alert(JSON.stringify(j));return;}
  g.jobId=j.jobId; $('#jobId').value=g.jobId; $('#status').textContent='job: '+g.jobId;
  const baseUrl = api(`/jobs/${g.jobId}/original.jpg`);
  const murl=(j.masks||{}).editable_surface||'';
  await initCanvas(baseUrl, murl);
};

// ===== tabs: 色卡 / 自訂 =====
function setTab(which){
  const a=$('#tabPreset'), b=$('#tabCustom');
  const p=$('#palettePreset'), c=$('#paletteCustom');
  if(which==='preset'){ a.classList.add('active'); b.classList.remove('active'); p.style.display='block'; c.style.display='none'; }
  else { b.classList.add('active'); a.classList.remove('active'); c.style.display='block'; p.style.display='none'; }
}
$('#tabPreset').onclick=()=>setTab('preset');
$('#tabCustom').onclick=()=>setTab('custom');

// ===== save mask =====
$('#btnSaveMask').onclick = async ()=>{
  if(!g.jobId){alert('先 /analyze');return;}
  const can=$('#maskCanvas'); const blob=await new Promise(r=>can.toBlob(r,'image/png'));
  const fd=new FormData(); fd.append('jobId',g.jobId); fd.append('mask',blob,'mask.png');
  const res=await fetch(api('/masks/save'),{method:'POST',body:fd}); const j=await res.json();
  if(!res.ok){alert(JSON.stringify(j));return;} alert('已儲存最終遮罩 ✅');
};

// ===== batch render =====
$('#btnBatch').onclick = async ()=>{
  if(!g.jobId){alert('先 /analyze');return;}
  const styles=Array.from($('#styleSelect').selectedOptions).slice(0,3).map(o=>o.value); if(styles.length<1){alert('至少選一種風格');return;}
  const payload={ jobId:g.jobId, styles, palette:{main:$('#cMain').value, acc1:$('#c1').value, acc2:$('#c2').value, acc3:$('#c3').value},
    logo:{ pos:$('#logoPos').value, scale:parseFloat($('#logoScale').value||'0.18'), opacity:parseFloat($('#logoOpacity').value||'0.9') } };
  const res=await fetch(api('/render/batch'),{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)});
  const j=await res.json(); if(!res.ok){alert(JSON.stringify(j));return;}
  const wall=$('#wall'); wall.innerHTML=''; g.imgs=j.images||[];
  g.imgs.forEach(it=>{ const fig=document.createElement('figure'); const img=document.createElement('img'); img.src=api(it.url); const cap=document.createElement('figcaption'); cap.className='small'; cap.textContent=`${it.style}｜keypoint_error=${(j.qc?.[it.style]?.keypoint_error??'')}`; fig.appendChild(img); fig.appendChild(cap); wall.appendChild(fig); });
};

// ===== furniture edit =====
$('#btnEdit').onclick = async ()=>{
  if(!g.jobId){alert('先 /analyze');return;}
  const maskFile=$('#editMask').files[0]; if(!maskFile){alert('請選局部遮罩');return;}
  const fd=new FormData(); fd.append('jobId',g.jobId); fd.append('mask',maskFile,'user_edit.png');
  const up=await fetch(api('/upload/mask'),{method:'POST',body:fd}); const uj=await up.json(); if(!up.ok){alert(JSON.stringify(uj));return;}
  const baseStyle=$('#baseStyle').value.trim(); const type=$('#opType').value;
  const ops=[ type==='replace'? {type:'replace', target:'object', mask:uj.maskUrl, spec:$('#editSpec').value} : {type:'recolor', target:'object', mask:uj.maskUrl, color:$('#editColor').value} ];
  const res=await fetch(api('/render/furniture-edit'),{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({jobId:g.jobId, baseImageId:baseStyle, operations:ops})});
  const j=await res.json(); if(!res.ok){alert(JSON.stringify(j));return;}
  $('#finalImg').src=api(j.imageUrl);
};

// ===== 初始：建立色卡 =====
buildPaletteGrid(); randPalette(); setTab('preset');

// ===== Painter v2: zoom/pan + edge assist + colored cursor =====
let painter = null;
async function initCanvas(baseUrl, maskUrl){
  const baseImg = new Image(); baseImg.crossOrigin="anonymous"; baseImg.src=baseUrl;
  const initMask = new Image(); initMask.crossOrigin="anonymous"; initMask.src=api(maskUrl);
  await new Promise(r=>baseImg.onload=r); await new Promise(r=>initMask.onload=r);

  const can = $('#maskCanvas'), ui = $('#uiCanvas');
  const ctx = can.getContext('2d'); const uictx = ui.getContext('2d');
  can.width = ui.width = baseImg.width; can.height = ui.height = baseImg.height;

  // Offscreen mask buffer: 白=鎖(不透明)；透明=可改
  const maskBuf = document.createElement('canvas'); maskBuf.width=baseImg.width; maskBuf.height=baseImg.height;
  const mctx = maskBuf.getContext('2d'); mctx.clearRect(0,0,maskBuf.width,maskBuf.height);
  mctx.drawImage(initMask,0,0,maskBuf.width,maskBuf.height);

  // Edge buffer
  const edgeBuf = document.createElement('canvas'); edgeBuf.width=baseImg.width; edgeBuf.height=baseImg.height;
  const ectx = edgeBuf.getContext('2d'); ectx.drawImage(baseImg,0,0);
  const eImg = ectx.getImageData(0,0,edgeBuf.width,edgeBuf.height);
  // Sobel edge
  const w=edgeBuf.width,h=edgeBuf.height; const gray=new Uint8ClampedArray(w*h);
  for(let i=0, p=0;i<eImg.data.length;i+=4, p++){ gray[p]=(eImg.data[i]*0.299 + eImg.data[i+1]*0.587 + eImg.data[i+2]*0.114)|0; }
  const Gx=[-1,0,1,-2,0,2,-1,0,1], Gy=[-1,-2,-1,0,0,0,1,2,1];
  const edge=new Uint8ClampedArray(w*h);
  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      let sx=0, sy=0, k=0;
      for(let j=-1;j<=1;j++) for(let i=-1;i<=1;i++,k++){
        const v = gray[(y+j)*w+(x+i)];
        sx += v*Gx[k]; sy += v*Gy[k];
      }
      const mag = Math.min(255, Math.hypot(sx,sy)|0);
      edge[y*w+x] = mag;
    }
  }
  const edgeImg = ectx.createImageData(w,h);
  let edgeThr = 60; // threshold
  function updateEdgeOverlay(){
    for(let p=0, i=0;p<w*h;p++, i+=4){
      const v=edge[p]; edgeImg.data[i]=64; edgeImg.data[i+1]=200; edgeImg.data[i+2]=255; edgeImg.data[i+3]=(v>=edgeThr? 180: 0);
    }
    ectx.putImageData(edgeImg,0,0);
  }
  updateEdgeOverlay();
  let showEdges=false;

  // View transform
  let scale=1, ox=0, oy=0; const MIN_S=0.2, MAX_S=6;
  let isPanning=false, spaceDown=false, lastX=0, lastY=0;
  const overlayOpacity = $('#overlayOpacity'); const opVal=$('#opVal');
  function render(){
    ctx.setTransform(scale,0,0,scale,ox,oy);
    ctx.clearRect(-ox/scale,-oy/scale, can.width/scale, can.height/scale);
    ctx.drawImage(baseImg,0,0);
    // draw mask with adjustable opacity
    const alpha = Math.max(0, Math.min(1, (parseInt(overlayOpacity.value,10)||35)/100));
    ctx.globalAlpha = alpha; ctx.drawImage(maskBuf,0,0); ctx.globalAlpha = 1;
    if(showEdges){ ctx.drawImage(edgeBuf,0,0); }
    // draw cursor
    uictx.setTransform(scale,0,0,scale,ox,oy);
    uictx.clearRect(-ox/scale,-oy/scale, ui.width/scale, ui.height/scale);
    if(cursor.visible){
      uictx.beginPath(); uictx.arc(cursor.x, cursor.y, cursor.r, 0, Math.PI*2);
      uictx.lineWidth = 2/scale; uictx.strokeStyle = (cursor.tool==='unlock')?'#22c55e':'#ef4444';
      uictx.stroke();
    }
    opVal.textContent = Math.round(alpha*100);
  }
  function screenToImage(sx, sy){ return {x:(sx-ox)/scale, y:(sy-oy)/scale}; }

  // Painting state
  const brush = $('#brush'); const brushVal=$('#brushVal');
  const undoStack=[], redoStack=[]; const MAX_STACK=20;
  let tool='unlock', drawing=false;
  const cursor = {x:0,y:0,r:parseInt(brush.value,10)||20, tool:'unlock', visible:false};

  function snapshot(){
    const m = mctx.getImageData(0,0,maskBuf.width,maskBuf.height);
    undoStack.push(m); if(undoStack.length>MAX_STACK) undoStack.shift(); redoStack.length=0;
  }
  function restoreFrom(stackFrom, stackTo){
    if(stackFrom.length===0) return;
    const cur = mctx.getImageData(0,0,maskBuf.width,maskBuf.height);
    stackTo.push(cur);
    const imgData = stackFrom.pop();
    mctx.putImageData(imgData,0,0);
    render();
  }
  function paintAt(ix,iy){
    const r = cursor.r;
    mctx.save();
    if(tool==='unlock'){ // erase to transparent
      mctx.globalCompositeOperation='destination-out';
      mctx.beginPath(); mctx.arc(ix,iy,r,0,Math.PI*2); mctx.fillStyle='rgba(0,0,0,1)'; mctx.fill();
    }else{ // lock: paint white
      mctx.globalCompositeOperation='source-over';
      mctx.beginPath(); mctx.arc(ix,iy,r,0,Math.PI*2); mctx.fillStyle='rgba(255,255,255,1)'; mctx.fill();
    }
    mctx.restore();
  }

  // Events
  document.querySelectorAll('[data-tool]').forEach(b=>{ b.onclick=()=>{ tool=b.getAttribute('data-tool'); cursor.tool=tool; render(); }; });
  document.getElementById('btnUndo').onclick=()=>restoreFrom(undoStack, redoStack);
  document.getElementById('btnRedo').onclick=()=>restoreFrom(redoStack, undoStack);
  brush.oninput=()=>{ cursor.r=parseInt(brush.value,10)||20; brushVal.textContent=brush.value; render(); };

  can.addEventListener('wheel', (e)=>{
    e.preventDefault();
    const rect=can.getBoundingClientRect();
    const mx=e.clientX-rect.left, my=e.clientY-rect.top;
    const before=screenToImage(mx,my);
    const s = Math.exp(-e.deltaY*0.001);
    const ns = Math.max(MIN_S, Math.min(MAX_S, scale*s));
    scale = ns;
    const after=screenToImage(mx,my);
    ox += (mx - (after.x*scale)) - (mx - (before.x*scale));
    oy += (my - (after.y*scale)) - (my - (before.y*scale));
    render();
  }, {passive:false});
  can.addEventListener('mousedown',(e)=>{
    const rect=can.getBoundingClientRect();
    lastX=e.clientX-rect.left; lastY=e.clientY-rect.top;
    if(spaceDown){ isPanning=true; return; }
    drawing=true; snapshot();
    const {x,y}=screenToImage(lastX,lastY); paintAt(x,y); render();
  });
  window.addEventListener('mousemove',(e)=>{
    const rect=can.getBoundingClientRect();
    const sx=e.clientX-rect.left, sy=e.clientY-rect.top;
    cursor.visible = (sx>=0 && sy>=0 && sx<=rect.width && sy<=rect.height);
    const pt=screenToImage(sx,sy); cursor.x=pt.x; cursor.y=pt.y;
    if(isPanning){
      ox += (sx-lastX); oy += (sy-lastY);
      lastX=sx; lastY=sy; render(); return;
    }
    if(drawing){ const {x,y}=pt; paintAt(x,y); render(); }
    else { render(); }
  });
  window.addEventListener('mouseup',()=>{ drawing=false; isPanning=false; });
  document.addEventListener('keydown',(e)=>{
    if(e.target.tagName==='INPUT' || e.target.tagName==='TEXTAREA') return;
    if(e.code==='Space') spaceDown=true;
    if(e.key==='e' || e.key==='E'){ tool='unlock'; cursor.tool=tool; render(); }
    if(e.key==='r' || e.key==='R'){ tool='lock'; cursor.tool=tool; render(); }
    if(e.key==='z' || e.key==='Z'){ e.preventDefault(); document.getElementById('btnUndo').click(); }
    if(e.key==='y' || e.key==='Y'){ e.preventDefault(); document.getElementById('btnRedo').click(); }
  });
  document.addEventListener('keyup',(e)=>{ if(e.code==='Space') spaceDown=false; });

  // Controls
  $('#btnZoomIn').onclick=()=>{ scale=Math.min(MAX_S, scale*1.2); render(); };
  $('#btnZoomOut').onclick=()=>{ scale=Math.max(MIN_S, scale/1.2); render(); };
  $('#btnZoomReset').onclick=()=>{ scale=1; ox=0; oy=0; render(); };
  $('#overlayOpacity').oninput=()=>render();
  $('#btnToggleEdges').onclick=()=>{ showEdges=!showEdges; render(); };
  $('#edgeThr').oninput=()=>{ edgeThr=parseInt($('#edgeThr').value||'60',10); $('#thrVal').textContent=edgeThr; updateEdgeOverlay(); render(); };
  $('#edgeRad').oninput=()=>{ $('#radVal').textContent=parseInt($('#edgeRad').value||'3',10); };

  function protectEdges(){
    const rad = parseInt($('#edgeRad').value||'3',10);
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        if(edge[y*w+x] >= edgeThr){
          mctx.save();
          mctx.globalCompositeOperation='source-over';
          mctx.beginPath(); mctx.arc(x,y,rad,0,Math.PI*2); mctx.fillStyle='rgba(255,255,255,1)'; mctx.fill();
          mctx.restore();
        }
      }
    }
  }
  function cleanSpecks(){
    const m = mctx.getImageData(0,0,w,h);
    const d = m.data;
    // simple 3x3 box blur on alpha, then threshold
    const alpha = new Uint8ClampedArray(w*h);
    for(let p=0, i=3;p<w*h;p++, i+=4) alpha[p]=d[i];
    const out = new Uint8ClampedArray(w*h);
    for(let y=1;y<h-1;y++){
      for(let x=1;x<w-1;x++){
        let s=0;
        for(let j=-1;j<=1;j++) for(let i=-1;i<=1;i++) s+= alpha[(y+j)*w+(x+i)];
        const avg = s/9;
        out[y*w+x] = (avg>180)? 255 : 0; // keep large areas
      }
    }
    // write back: 255 -> opaque white, 0 -> transparent
    for(let p=0, i=0;p<w*h;p++, i+=4){
      d[i]=255; d[i+1]=255; d[i+2]=255; d[i+3]=out[p];
    }
    mctx.putImageData(m,0,0);
  }
  $('#btnProtectEdges').onclick=()=>{ protectEdges(); render(); };
  $('#btnCleanSpecks').onclick=()=>{ cleanSpecks(); render(); };
  $('#btnSmartFix').onclick=()=>{ protectEdges(); cleanSpecks(); render(); };

  painter = { render, maskBuf, baseImg };
  render();
}

// ===== 色卡初始化 =====
function buildPaletteGrid(){ const grid = $('#paletteGrid'); grid.innerHTML=''; PALETTES.forEach(p=> grid.appendChild(makePalCard(p)) ); }
function makePalCard(p){ const div = document.createElement('div'); div.className='palcard'; div.dataset.id=p.id; div.innerHTML = `<div class="swrow"><div class="sw" style="background:${p.c[0]}"><label>主</label></div><div class="sw" style="background:${p.c[1]}"><label>配1</label></div><div class="sw" style="background:${p.c[2]}"><label>配2</label></div><div class="sw" style="background:${p.c[3]}"><label>配3</label></div></div><div class="name"><span>${p.name}</span><span class="small">${p.c.join(' ')}</span></div>`; div.onclick = ()=>applyPalette(p.c, div); return div; }
function applyPalette(c, cardEl){ $('#cMain').value = c[0]; $('#c1').value = c[1]; $('#c2').value = c[2]; $('#c3').value = c[3]; document.querySelectorAll('.palcard').forEach(x=>x.classList.remove('selected')); if(cardEl) cardEl.classList.add('selected'); }
function randPalette(){ const p = PALETTES[Math.floor(Math.random()*PALETTES.length)]; const card = document.querySelector(`.palcard[data-id="${p.id}"]`); applyPalette(p.c, card); }
buildPaletteGrid(); randPalette();
</script>
